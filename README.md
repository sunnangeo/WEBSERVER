# webserver

<<<<<<< HEAD
该项目是用C++11开发的WEB集群服务器。可以处理浏览器的请求并返回响应的网站页面，实现了与Mysql交互的用户注册以及登陆操作，利用Nginx实现了集群服务器的负载均衡，并使用webbench进行了压力测试
=======

使用IO多路复用(Epoll)和线程池技术实现的reactor模式的高性能WEB服务器，使用nginx负载均衡实现了集群，并使用了webbenchh进行了压力测试
>>>>>>> a0e1674dbfa487578ae325b63e250710350d3894

## 主要工作流程

- 主要工作：
  1. 利用IO多路复用Epoll，双模式线程池实现了Reactor事件处理模式***(通过GDB调试解决了线程池回收资源时产生的死锁问题)\***
  2. 利用正则与状态机解析HTTP请求报文，实现处理静态资源的请求
  3. 利用标准库容器实现自动增长的缓冲区以及基于小根堆实现的定时器，可以关闭超时的非活动连接
  4. 利用单例模式实现了动态数据库连接池以及用户注册登录操作(***通过GDB调试解决了配置文件读取错误的问题\***)
  5. 利用Nginx中的轮询算法实现了集群服务器的负载均衡

主线程监听连接

主线程让epoll监听活跃的文件描述符

处理完之后开工作线程

工作线程任务(读写是分开的，不一定是同一个线程搞操作)

读写缓冲区是数据httpconn的，httpconn是一个类，一个用户一个实例。所以直接独立了。

- read客户端数据(用非阻塞IO)  
  - 有个读缓冲，每个连接独享一个读和写缓冲，有个65K缓冲区保证能一次读完，读不完就扩容
- 以下业务逻辑  
  - 先去看读缓冲有没有数据
  - 解析HTTP
  - 生成响应数据
  - 封装响应传回去

## 功能

### 利用IO复用技术Epoll与线程池实现多线程的Reactor高并发模型

#### 一、线程池

为了解决由于多个线程频繁创建与销毁以及多个线程之间调度引发的资源浪费的问题，我们可以提前创建好适当个数的子线程，当有任务到来时，主线程把任务放入已加锁的共享的工作队列中，并使用条件变量唤醒睡眠在工作队列中的子线程，让子线程执行任务。

1. 线程数量：一般和CPU的核心数量差不多，如果是CPU密集型的任务，比如图像处理和视频剪辑，那么线程数量和CPU核心数相等就行；如果是IO密集型的任务，线程数量一般要多于CPU的核数，比如设置为核心数的两倍。
2. 锁与条件变量：使用C++11的mutex与condition_variable，可以使用lock_guard与unique_lock这两个类，当创建对象时，就已加锁，当对象析构时会自动解锁，这样可以避免忘记解锁而造成死锁，其中unique_lock可以加锁解锁比较自由。
3. 工作队列与任务：使用包装器将此处的任务包装为一个可调用对象（类似函数一样可以调用），也就是事件对应的回调函数，当主线程监测到有可读或可写的事件发生时，可以通过绑定器生成一个仿函数，并将这个仿函数加入到工作队列中，同时使用notify_one()唤醒一个子线程。当子线程被唤醒后，调用工作队列中front的可调用对象实现回调操作。

线程池：
两个类：线程类和线程池类

1.线程类：线程函数对象，线程Id，构造函数，启动线程
2.线程池类：表示线程池的状态
两个容器：存放任务的队列，线程号-线程对象哈希表
1.任务队列：需要使用锁，有最大的限制
2.哈希表：为了回收资源时，方便将记录的线程删除
三个条件变量：任务队列不满、任务队列不空、资源是否回收
三个函数：提交任务、开启线程池、定义线程函数
1.开启线程池：使用make_unique初始化线程类的智能指针，构造函数参数为把线程函数绑定线程Id的函数对象，在开启线程
2.定义线程函数：循环从队列中取任务，执行任务，任务队列为空，停在notEmpty条件变量上，如果是cache模式，使用notEmpty条件变量的wait_for函数等一秒，如果是因为超60s返回，就结束这个线程
3.提交任务：使用可变参数模板编程(Func&& func, Args&&... args)，用户可以传入任意个数和类型的参数
c++11的线程类不能搞定返回值，所以加了一个类似function<>的函数包装器packaged_task搞定，他和function的不同在于可以通过get_future()方法获取返回值，返回值可以用future<>接收

using RType = decltype(func(args...));
Task就是函数对象，但是无法确定返回值，可以利用一个中间层function<void()>，

问题：回收线程池资源的时候发生了死锁的情况

一开始的思路是，当线程池析构的时候，会把线程池结束标志设置为false，唤醒notEmpty条件变量，然后等待线程池里面所有的线程结束，此时线程可能有两种状态，1、在notEmpty上wait；2、执行任务中，所以需要一个条件变量exitCond去等待线程结束，如果线程容器中的size为0，可以往下走。在线程函数方，用一个循环，只要线程结束标志不为结束，就一直取任务执行任务，如果标志为结束，就结束这个线程并唤醒exitCond。但是有问题。

########################## version_1 ###############################

```c++
*************线程代码***************
while (isPoolRunning_) {
    Task task;
    lock(taskQueMtx_);
    while (taskQue_.size() == 0) {        
        notEmpty_.wait(lock);//fix or cache  //case1
        if (!isPoolRunning_) {
            回收线程并exitCond_.notify_all();
        }
    }
    task();//case2
}
回收线程并exitCond_.notify_all();
```

```c++
*************线程池代码***************
~ThreadPool() {
    isPoolRunning_ = false;
    notEmpty_.notify_all();
    lock(taskQueMtx_);
    exitCond_.wait(lock, [&]() -> bool { return threads_.size() == 0; });
}
```

########################## version_2 ###############################
解决了两种死锁问题

```c++
*************线程代码***************
while (isPoolRunning_) {
    Task task;
    lock(taskQueMtx_);
    while (isPoolRunning_ && taskQue_.size() == 0) {        
        notEmpty_.wait(lock);//fix or cache  //case1
    }
    if (!isPoolRunning_) {
        break;
    }
    task();//case2
}
回收线程并exitCond_.notify_all();
```

```c++
*************线程池代码***************
~ThreadPool() {
    isPoolRunning_ = false;
    lock(taskQueMtx_);
    notEmpty_.notify_all();
    exitCond_.wait(lock, [&]() -> bool { return threads_.size() == 0; });
}
```

########################## version_3 ###############################
线程池对象除了作用域后，任务就不执行了

```c++
*************线程代码***************
for (;;) {
    Task task;
    lock(taskQueMtx_);
    while (taskQue_.size() == 0) {        
        if (!isPoolRunning_) {
            回收线程并exitCond_.notify_all();
        }
        notEmpty_.wait(lock);//fix or cache
    }
    task();
}
```

```c++
*************线程池代码***************
~ThreadPool() {
    isPoolRunning_ = false;
    lock(taskQueMtx_);
    notEmpty_.notify_all();
    exitCond_.wait(lock, [&]() -> bool { return threads_.size() == 0; });
}
```

#### 二、IO复用技术epoll

主要是为了在单个线程或进程中，可以监测多个文件描述符的变化，提高并发能力。I/O复用虽然能同时监听多个文件描述符，但它本身是阻塞的。并且当多个文件描述符同时就绪时，如果不采取额外的措施，程序就只能按顺序依次处理其中的每一个文件描述符，这使得服务器程序看起来像是串行工作的。如果要实现并发，只能使用多进程或多线程等编程手段。

1. BIO模型：由于socket通信的中的accept和read等默认都是阻塞函数，所以单线程或进程的情况下，若有一个客户端连接并且无读事件时，其他客户端无法连接服务器，解决方法就是每一个客户端分配一个线程，但是如果客户端数量较大，此方法显然不行。

2. NIO模型：把文件描述符都设置为非阻塞，程序就会一直轮询检查是否有客户端连接，但是还是只能一次监测一个文件描述符。

3. IO多路复用：一次可以检测多个文件描述符。

   select：使用一个文件描述符集合检测多个文件描述符的变化。4个缺点。

   poll：解决了两个缺点。而且有较为丰富的事件类型的监测

   epoll：通过epoll_create()创建了一epoll对象，返回了一个用于操作这个内存的文件描述符，这个对象中维护了两个重要的数据结构，一个是我们要检测的文件描述符集合，是用红黑树实现的，我们可以通过epoll_ctl()向里面添加或删除需要检测的文件描述符和想要监测的事件，红黑树的遍历以及增删改查的效率在数据量大的时候是很客观的；另外一个是用一个双链表结构实现的一个就绪队列，当检测到文件描述符有事件发生时，就会把这个文件描述符添加到就绪队列中，此时用户得到的epoll_event数组中便是事件发生的文件描述符，只需遍历返回值个数即可。其中LT和ET为两种处理模式，当使用ET模式时，函数要设置为非阻塞，并且要一次性循环读取完数据。本项目对Epoll进行了封装

#### 三、高效的事件处理模式

1. reactor模式：要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元），将 socket 可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。
2. proactor模式：在把任务交给工作线程时，数据的读写就已经委托内核完成了，工作线程只需要处理业务逻辑。

### 利用正则与状态机解析HTTP请求报文，实现处理静态资源的请求

#### 一、HTTP协议以及报文

HTTP是一个简单的请求-响应协议，首先客户端发送请求报文，服务器接受到请求报文将数据读取到readbuf和一块65k的缓存中，成功后利用状态机进行解析，得到诸如请求方法，请求资源路径以及请求头等报文信息，解析后把相应的响应报文进行封装，其中响应首行、响应头中的数据存在writebuf中，响应体为资源文件open得到一个文件描述符，通过内存映射得到一个指向映射的那块内存的指针。

其中报文由首行、头、空行、体组成，每行由/r/n结束。请求首行由请求方法（GET POST）、URL、等组成；响应首行由状态码（200 400 500）、状态码描述等组成。每个客户端信息对应一个httpconn对象，由一个哈希表以文件描述符作为key存储，其中用户个数用一个静态原子变量来存储，并封装了一个httprequest类和httpresponse类。

#### 二、有限状态机

不同的报文字段类型对应一种状态，每种状态都对应业务逻辑，用while循环再用switch判断，当一种业务逻辑完成后，需要改变状态。比如先解析请求首行，成功时将状态改变为请求头，依次下去解析，同时调整readpos的位置。

#### 三、正则表达式

描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串。

### 利用标准库容器封装char，实现自动增长的缓冲区

每一个客户端对应一个httpconn对象，每个httpconn中又有封装的readbuf\writebuf，其中有一个具体装数据的vector<char>初始设置为1k，用于把内核中的数据与用户区数据的交互，定义了两个索引变量readpos和writepos用于确定读写的位置。

1. 在read过程中，又定义了一个65k的buff，保证能把所有的数据读出来。使用readv指定以上两块内存地址，在readbuf数据满了之后，把剩余的数据读到buff中。若buff中的数据大小够被readbuf装下（若可写的部分能装下就直接装，如不能，需要把已经解析的位置也用来装，先把数据向前移动解析的位置，在装），直接复制，若不能，则扩容buff数据的大小后再复制。
2. 在write过程中，由于有两块内存，所以使用writev将数据写入。如果写到了第1块内存，调整下次写的位置与长度，并将readpos移动已写的长度；如果写到第二块内存，表明数据都写出去了，调整下次写的位置与长度，并将readpos和writepos都置为0。

### 基于小根堆实现的定时器，关闭超时的非活动连接

小根堆是由一个二叉树结构所维护的，它满足每一个子树的最小值都是头结点的值，通过heapinsert和heapity调整小根堆的结构。每一个客户端都有一个时间戳结构体，其里面维护关闭连接的回调函数、超时时间以及文件描述符等。当有新的客户端连接进来时会将其加入堆结构；当已连接的客户端有数据可写或可读时，会重新调整定时器的超时时间，小根堆会根据超时时间调整其在堆结构中的位置。

每次在epoll_wait之前要确定他的阻塞时长，如果不阻塞无法关闭非活动的连接，如果阻塞就会一直调用从而浪费cpu性能；所以我们要通过一个超时时间来设定他的阻塞时长，那么这个超时时间应该如何计算呢？那就是在调用epoll_wait前，首先把所有的超时的非活动连接全部关闭，此时经过小根堆调整之后，数组中的第一个元素就是距离超时时间最近的一个连接，用这个连接的时间减去当前时间就时需要的阻塞时间。

关闭连接是怎么做的呢？循环从小根堆里拿出第一个元素，将他的超时时间减去当前时间，如果大于零证明还没有到超时时间，若小于零则执行关闭连接的回调函数。

### 利用单例模式与阻塞队列实现异步的日志系统，记录服务器运行状态

日志的功能本质就是向文件中写数据，如果是同步的日志，当执行日志写数据的时候，不能向下执行程序，所以可以用异步的日志，即使用子线程维护一个队列去写数据

### 利用单例模式实现了数据库连接池，减少数据库连接建立与关闭的开销，同时实现了用户注册登录功能

频繁的数据库连接销毁操作会浪费内存资源，降低程序运行效率，所以预先准备好一个数据库连接池，可以提升程序运行的效率。

首先将MYSQL的一系列操作封装为一个类，用户对外调用接口即可进行数据库相应的操作,比如建立连接（mysql_real_connect)、以及对数据的增删改查操作（mysql_query）。

数据库连接池对象只需要一个就可以把多个数据库连接取出来，所以使用单例设计模型，此处使用懒汉式即对象在使用时才创建，所以在多线程时需要加锁避免创建多个对象，需要将构造函数设置为私有并且删除拷贝构造函数以及=的操作符重载。在C++11中，使用静态局部变量是线程安全的，所以提供一个静态方法返回这个唯一的对象。在数据库连接池中维护了一个存储数据库连接的队列，以及各种连接需要的信息。在构造函数中，创建最小连接数个数据库连接。创建两个子线程，其中一个负责监测有没有需要生产的连接，另一个负责监测有没有销毁的连接。当数据库连接池队列中的数据库连接小于最小连接个数时，就需要创建数据库连接，否则将线程阻塞；当数据库连接队列中最前面的数据库连接的空闲时长大于最大的空闲时长，就需要销毁数据库连接，否则将线程阻塞。最后利用一个对外的接口让用户可以获取到池子中的数据库连接，当使用完毕后把数据库连接放入池子中。使用一个共享的智能指针管理数据库连接，指定它的删除器对应的处理动作，即把数据库连接放入到池子中。

使用POST请求解析表单数据，并将数据提交到数据库。使用post请求时，表单数据在请求体中。

## 环境要求

- Linux

- C++11
- MySql

## 项目启动

需要先配置好对应的数据库，然后在项目目录自动构建可执行程序。

```bash
// 建立webserver库
create database webserver;

// 创建user表
USE webserver;
CREATE TABLE user(
    username char(50) NULL,
    password char(50) NULL
)ENGINE=InnoDB;

// 添加数据
INSERT INTO user(username, password) VALUES('name', 'password');
```

```bash
./autobuild.sh
```

webbench压测
./webbench -c 1000 -t 10 127.0.0.0.1:10000

# 面试问题

1. 讲讲WEB服务器设计思路

2. 讲讲线程池，子线程数量怎么选择的，线程池子线程在做什么

3. 讲讲如何停止线程池

4. 在哪里控制线程池的终止

5. 你这个项目如何处理黏包问题的

6. 你的服务器在客户端超时后怎么处理的

7. 你是如何进行HTTP报文解析的，主从状态机怎么做的

8. 线程池中的工作线程是一直等待吗？

   是的，若有新的任务就会唤醒睡眠在工作队列中的子线程。

9. 你的线程池工作线程处理完一个任务后的状态是什么？

   如果请求队列为空，则该线程在线程池中等待；若不为空，则该线程跟其他线程一起进行任务的竞争。

10. 如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？
